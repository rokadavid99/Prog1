<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
           <para>Egy magot 100%-ban a while illetve a for ciklus alkalmazásával is pörgethetünk.</para>
        <para><emphasis role="bold">Megoldás while ciklussal:</emphasis><link
                xlink:href="https://github.com/rokadavid99/Prog1/blob/master/loopw.c"
            /><programlisting>#include &lt;stdio.h>
int main(){
    
    while(1);

    return 0;
}

		</programlisting></para>
        <para>A két megoldás közül ez az egyszerűbb, mondhatni stílusosabb.</para>
        <para/>
        <para><emphasis role="bold">Megoldás for ciklussal:</emphasis><link
                xlink:href="https://github.com/rokadavid99/Prog1/blob/master/loopf.c"
            /><programlisting>#include &lt;stdio.h>


int main(){
    for(;;);

    return 0;


}
</programlisting></para>
        <para>Viszont ez a megoldás egyértelművé teszi a program megértését a két db ";;" jel miatt, ami kifejezi a szándékunkat.</para>
        <para><emphasis role="bold">Több mag 100%-on:</emphasis><link
                xlink:href="https://github.com/rokadavid99/Prog1/blob/master/allcore100.c"
            /><programlisting>#include &lt;stdio.h>
#include &lt;unistd.h>
#include &lt;omp.h>

int main(){

#pragma omp parallel
#pragma omp while

	while(1);

return 0;
}</programlisting></para>
        <para>Ahhoz, hogy több magot 100%-on tudjunk futtatni, a parallel pragma-t kell fehasználnunk,
              ami az őt követő utasításokat több szálon futtatja.Nem szabad figyelmen kívűl hagyni,
              hogy a kód elején meg kell hívnunk az omp.h headert. 
        </para>
        <para><emphasis role="bold">Egy mag 0%-on:</emphasis><link
                xlink:href="https://github.com/rokadavid99/Prog1/blob/master/loop0.c"
            /></para>
        <para>
            <programlisting>#include &lt;stdio.h>
#include &lt;unistd.h>


int main(){

    while(1){

    sleep(100);
   
     }
    return 0;

}</programlisting>
        </para>
        <para>Amikor egy magot szeretnénk használni és azt is 0%-on, akkor azt a sleep függvény segítségével
             tehetjük meg. A sleep függvény használatához meg kell hívni az unistd.h headert.
        </para>            

    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
               <para>
           Labdapattogtatás if használatával:
        </para>
<programlisting language="c"><![CDATA[
#include <curses.h> 
#include <unistd.h> 
int main ( void )
{
    WINDOW *ablak;   
    ablak = initscr (); 
    int x = 0;
    int y = 0;
                    
    int xnov = 1;   
    int ynov = 1;
    int mx;  	
    int my;
    for ( ;; ) {	
                    
                    
        getmaxyx ( ablak, my , mx ); 		
				     		
        mvprintw ( y, x, "O" ); 
        refresh ();	
       
         usleep ( 50000 );  
	clear(); 
                    
        x = x + xnov;	 
        y = y + ynov;
        if ( x>=mx-1 ) { 
            xnov = xnov * -1;
        }
        if ( x<=0 ) {
            xnov = xnov * -1;
        }
        if ( y<=0 ) { 
            ynov = ynov * -1;
        }
        if ( y>=my-1 ) { 
            ynov = ynov * -1;
        }
    }
    return 0;
}
]]></programlisting>
        <para>
           Labdapattogtatás if nélkül: <link xlink:href="https://github.com/rokadavid99/Prog1/blob/master/labda.c">https://github.com/rokadavid99/Prog1/blob/master/labda.c</link>
        </para>
        <programlisting language="c"><![CDATA[
#include <curses.h> 
#include <unistd.h> 
#include <stdlib.h> 
int main ( void )
{
    WINDOW *ablak;   	 
    ablak = initscr (); 
    int mx;  	
    int my;
    int xj = 0, xk = 0, yj = 0, yk = 0; 
    for ( ;; ) {	
        getmaxyx ( ablak, my , mx ); 
                    
        
        xj = (xj - 1) % mx;
        xk = (xk + 1) % mx;
        yj = (yj - 1) % my;
        yk = (yk + 1) % my;						
				     		
        
        mvprintw ( abs (yj + (my - yk) ), abs (xj + (mx - xk)) , "O" ); 	
        refresh ();		
        usleep ( 50000 );	
	clear();	
    }
    return 0;
}
]]></programlisting> 
<para>
            A feladat megoldható a maradékos osztás művelet használatával(%) hiszen az előző példából tudhatjuk hogy a labda mozgatása során
             pl az oszlop kordinátája így változik 1,2,3,4,5,4,3,2,1,2... tehát folyamatosan hullámzik ameddig el nem éri a határértéket
              ez maradékos osztásal is elérhető de mivel az az elért érték után rögtön nullára esik vissza: 1,2,3,4,5,0,1,2,3,4,5,0...
             ezért 2 sorozat öszemosására van szükségünk:  
</para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/rokadavid99/Prog1/blob/master/szohossz.cpp"></link>
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>

int main()
{

int szo=1;
int lepes=1;

while(szo<<=1)
 ++lepes;

printf("%i\n",lepes);

}
]]></programlisting> 
        <para>
            Ez a bitshift operátor, a megadott változó memoriában tárolt bitjein végez műveletet, eltolja azokat annyival
(itt balra) amekkora értéket megadunk neki.A képernyőn megjelenő szám a 32, tehát ennyi bitből áll egy gépi szó.
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/rokadavid99/Prog1/blob/master/pagerank.c"></link>
        </para>
        <programlisting language="c"><![CDATA[
#include <stdio.h>
#include <math.h>

void kiir (double tomb[], int db)
  {
  
  int i;
  for (i=0; i<db; i++)
  printf("PageRank [%d]: %lf\n", i, tomb[i]);
  
  }

double tavolsag(double pagerank[],double pagerank_temp[],int db)
{
double tav = 0.0;
int i;
for(i=0;i<db;i++)
tav +=abs(pagerank[i] - pagerank_temp[i]);
return tav;
}

int main(void)
{
  double L[4][4] = {
  {0.0, 0.0, 1.0 / 3.0, 0.0},
  {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
  {0.0, 1.0 / 2.0, 0.0, 0.0},
  {0.0, 0.0, 1.0 / 3.0, 0.0}
  };

  double PR[4] = {0.0, 0.0, 0.0, 0.0};
  double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

  int i,j;


  for (;;)
  {

  for (i=0;i<4;i++)
    {
    PR[i]=0.0;
    for (j=0;j<4;j++)
      PR[i]+=L[i][j]*PRv[j];
    }

    if ( tavolsag(PR,PRv, 4) < 0.0000001)
    break;
  
    for(i=0;i<4;i++)
      PRv[i] = PR[i];
  
  }
  kiir (PR,4);
  return 0;

} 
        
        
        ]]></programlisting> 
        <para>
        A PageRank egy módszer weblapok osztályozására, az alapötlet: azok a lapok jobb minőségüek amelyekre
        jobb minőségű lapok mutatnak.
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <programlisting language="c"><![CDATA[
library(matlab)

stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]></programlisting>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>                
